\documentclass{article}
\usepackage{mathtools}
\begin{document}

\title{Finding an initial Point}

\author{Mike Flynn}
\maketitle
\section*{Minimizing distance from the origin}

The thought process behind this idea was so: We need to get a point
from the inside of a polytope, given the constraint equations. These
equations give us a k-plane that will always go through the plane:
$x_1 + x_2 + \dots + x_n = 1$. Since the ``triangle'' defined by the
intersection of this plane and the constraints $x_i > 0$ is already
very close to zero, I assumed that any intersection of this plane with
another constraint would automatically have it's closest point within
the ``triangle'', however, this is only true if the intersection
``goes through the triangle'' in the first place, or so it seems.
\\ \\
\noindent The derivation is as follows:
\\ \\
\noindent The contraint equation $Ax=b$ can be though of geometrically
as sequentially restricting $x$ to plane by plane, with each row of
$A$ being a plane. It is a basic result of linear algebra that any
plane can be represented by the equation $ n * x = c$ where n is a
vector that is normal to the plane, and c is some constant
(i.e. $x+y+z = [1,1,1] * [x,y,z] = 1$). This is exactly what the rows
of $A$ are, normal vectors.

$$ A = \begin{bmatrix}\mathbf{n_1} \\\mathbf{n_2} \\ \vdots \\ \mathbf{n_n} \end{bmatrix} $$
\noindent
This will help because the shortest distance between a point and a
plane is the perpendicular distance between them, and therefore this
distance vector must be in line with a normal vector. For this
distance from the origin, this vector must be the position. It follows
that:

$$ x = \sum_{j=0}^n \mathbf{n_j}c_j = A^T c$$

\noindent
We can now use the two equations for $x$ to solve for it:

$$ A x = b$$
$$ x = A^Tc$$
Therefore:

$$ c = (AA^T)^{-1}b $$
Finally:

$$ x = A^T(AA^T)^{-1}b$$

\noindent
I implemented this code as follows, which works fine in low dimensions
but stop's being so good in higher dimensions:

<<impl>>=
find_x0 <- function(A, b) {
    return(t(A) %*% solve(A %*% t(A)) %*% b)
}
A = matrix(1, ncol = 3, nrow = 1)
A = rbind(A, rnorm(3)) # A random constraint, mimicking value
b = A %*% c(.2, .3, .5) # A random "intial" portfolio to set b
x0 = find_x0(A, b)
b
A %*% x0
x0

## This stops working nicely for jan
data(jan)
A = matrix(1, ncol = nrow(jan), nrow = 1)
A = rbind(A, jan$value)
A = rbind(A, jan$growth)
b = A %*% jan$portfolio
b
x0 = find_x0(A, b)
length(which(x0 > 0))
length(which(x0 < 0))
A %*% x0
@

As you can see, some of the weights are negative, which we do not
want.

\section{Changing up: going to quadratic programming}

After suggestions from colleagues, we move back to an attempt at
quadratic programming to solve our problem. The package
\verb+quadprog+ will solve the following problem for $b$:

$$ \text{Min}(-d^Tb + 1/2b^TDb) \text( given that ) A^Tb >= b_0$$

Since it similar to linear programming, it can be assumed that this
method will bias towards the edges, which in fact it does, however, it
does not exclusively go to corner solutions, like linear programming
does, and so might be a better way to go about solving this. An
example in 3D:

<<3dexample>>=
getWeights.quad <- function(A, b, n, verbose = FALSE) {

    w = matrix(0, ncol = n, nrow = ncol(A))
    if(verbose) cat("Portfolios created: 0")
    for(i in 1:n) {
        sol = solve.QP(Dmat = diag(2, ncol(A)), dvec = rnorm(ncol(A)), Amat = t(rbind(A, diag(1, ncol(A)))), bvec = c(b, rep(0, ncol(A))), meq = nrow(A))
        w[,i] = sol$solution
        if(verbose) {
            for(j in 1:nchar(paste(i-1))) cat("\b")
            cat(paste(i))
        }
    }
    return(w)
}

Amat = matrix(1, ncol = 3, nrow = 1)
b = 1
w = getWeights.quad(A, b, 1000)
scatterplot3d(x = w[1,], y = w[2,], z = w[3,], angle = 160)
@

\end{document}
