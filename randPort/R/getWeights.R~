#' Generates weights to a new portfolio, randomly, and fulfilling
#' equality constraints.

#' Fulfills equality constraints while maintaining randomness by
#' using a Monte Carlo Random Walk.

#' @param Emat This is the matrix of the equality constraint coefficients
#' @param x0 An original solution to the constraints
#' @param n Number of random solutions to output

#' @keywords Random-Portfolio Matching-Portfolio Monte-Carlo

#' @export
#' @examples
#' Emat = matrix(1, ncol = 3, nrow = 1)
#' x0 = c(.3, .3, .4)
#' getWeights(Emat, x0, 1)
getWeights <- function(Emat, x0, n, verbose = FALSE) {
    Z = Null(t(Emat))
    ret = matrix(0, nrow = length(x0), ncol = n + 1)
    ## Would it be better to use apply here?
    nc = ncol(Z)
    mn = mean(x0)
    ret[, 1] = x0 + Z %*% rnorm(nc, 0, mn)/sqrt(nc)
    k = 0
    if(verbose) cat("Created Vectors: ")
    if(verbose) cat(paste(k))

    for (i in 2:(n + 1)) {
        ret[, i] = ret[, i - 1] + Z %*% rnorm(nc, 0, mn)/sqrt(nc)
        m = k + 1;
        while(any(ret[, i] < 0)) {
            reflection = rep(0, ncol(Emat))
            overdist = rep(0, ncol(Emat))
            overdist[which(ret[, i] < 0)] = ret[, i][which(ret[, i] < 0)]
            dist = sqrt(sum(overdist^2))
            str = paste("Distance from walls: ", dist)
            cat(str)
            for (j in 1:ncol(Z)) {
                proj =  Z[, j] * (overdist %*% Z[, j])/Z[,j] %*% Z[, j]
                reflection = reflection  - proj
                overdist = overdist - proj
            }
            ret[,i] = ret[,i] + 2*reflection
            for(j in 1:nchar(str))  cat("\b")
            ##if(verbose) cat(paste(m))
            ##k = m
            ##m = k + 1
        }
        if(verbose) for(i in 1:nchar(paste(k)))  cat("\b")
        if(verbose) cat(paste(m))
        k = m
    }
    ret = ret[, 2:(n + 1)]
    if(verbose) cat("\n")
    return(ret)
}
