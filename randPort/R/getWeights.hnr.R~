#' Uniformly samples from {A*x=A*x0} U {x>0}
getWeights.hnr <- function(A, b = NULL, x0 = NULL, n, discard = 0) {
    stopifnot(!is.null(x0) || !is.null(b))
    if(is.null(x0)) {
        str = "Finding an intial solution..."
        cat(str)
        ##l = lsei(E = A, F = b, G = diag(ncol(A)), H = rep(0, ncol(A)))$X
        l = t(A) %*% solve(A %*% t(A)) %*% b
        if(!(all(l > 0))) {
            for(i in 1:nchar(str)) cat("\b")
            str = "Using mirror algorithm to find inner solution...\n"
            cat(str)
        }
        y = getWeights(A, l, 1, FALSE)
        for(i in 1:nchar(str)) cat("\b")
    } else {
        y = x0;
        if(!is.null(b)) stopifnot(A %*% x0 == b)
    }
    ## resolve weird quirk in Null() function
    if(ncol(A) ==1) {
        Z = Null(A)
    } else {
        Z = Null(t(A))
    }
    X = matrix(0, nrow = length(y), ncol = n + discard)
    cat("Random Walk\nDone with: ")
    str = "0"
    cat(str)
    for(i in 1:(n+discard)) {
        tmin=0;tmax=0;
        while(tmin ==0 && tmax ==0) {
            ## r is a random unit vector
            r = rnorm(ncol(Z))
            r = r/sqrt(sum(r^2))

            ## d is a unit vector in the appropriate k-plane pointing in a
            ## random direction
            u = Z%*%r
            c = y/u
            ## determine intersections of x + t*u with edges
            tmin = max(-c[u>0]); tmax = min(-c[u<0]);
            if(tmin==0 && tmax ==0) {
                for(j in 1:nchar(str)) cat("\b")
                str = paste(i-1, ", found bad direction(s)")
                cat(str)
            }
        }

        ##writeLines(paste("tmin: ", tmin, "\ntmax: ", tmax, "\n", sep = ""))
        ## chose a point on the line segment
        y = y + (tmin + (tmax - tmin)*runif(1))*u;
        X[,i] = y
        for(j in 1:nchar(str)) cat("\b")
        str = paste(i)
        cat(str)
    }
    cat("\n")
    return(X[,(discard+1):ncol(X)])
}
